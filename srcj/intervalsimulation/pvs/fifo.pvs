simple_fifo[N: nat]: THEORY
BEGIN

  data: TYPE+
  port: TYPE = upto(N)
  event: TYPE = [# port: port, data: data #]

  state_opt: DATATYPE
  BEGIN
    Reject: Reject?
    E: E?
    F(d: data): F?
  END state_opt

  IMPORTING fsm_def[event,state_opt,Reject]

  fsm_name: TYPE = below(N)

  so: VAR state_opt
  s: VAR state
  n: VAR fsm_name
  l: VAR nat
  d: VAR data
  p: VAR port
  e: VAR event
  t: VAR trace

  data_trace(t): trace[data] = (# length := t`length, seq := LAMBDA (i: below(t`length)): t`seq(i)`data #)

  data_trace_empty: LEMMA data_trace(empty_trace) = empty_trace

  data_trace_add: LEMMA data_trace(add(t, e)) = add(data_trace(t), e`data)

  port_event?(p)(e): bool = e`port = p

  data_trace(p, t): trace[data] = data_trace(proj(t, port_event?(p)))

  data_trace_p_empty: LEMMA data_trace(p, empty_trace) = empty_trace

  data_trace_p_add_this: LEMMA e`port = p IMPLIES data_trace(p, add(t, e)) = add(data_trace(p, t), e`data)

  data_trace_p_add_other: LEMMA e`port /= p IMPLIES data_trace(p, add(t, e)) = data_trace(p, t)

  simple_event?(n)(e): bool = e`port = n OR e`port = n+1

  simple_nextstate(n)(s: state, e: (simple_event?(n))): state_opt =
    CASES s OF
      E: IF e`port = n THEN F(e`data) ELSE Reject ENDIF,
      F(d): IF e`port = n+1 & e`data = d THEN E ELSE Reject ENDIF
    ENDCASES

  simple_fsm(n): fsm =
    (#
      event? := simple_event?(n),
      initial := E,
      nextstate := simple_nextstate(n)
    #)

  valid_trace?(t): bool = FORALL n: valid_trace(simple_fsm(n))(t)

  valid_trace: TYPE = (valid_trace?)

  vt: VAR valid_trace

  data_in(t): trace[data] = data_trace(0, t)

  data_out(t): trace[data] = data_trace(N, t)

  simple_invariant(n)(t, s): bool = 
    IF even?(t`length) THEN
      s = E & data_trace(n, t) = data_trace(n + 1, t)
    ELSE
      s = F(last(t)`data) & last(t)`port = n & data_trace(n, t) = add(data_trace(n+1, t), last(t)`data)
    ENDIF

  even_odd: LEMMA even?(l) & NOT even?(l+1) OR NOT even?(l) & even?(l+1)

  simple_invariant_step: LEMMA
    simple_event?(n)(e) AND simple_invariant(n)(t, s) AND simple_nextstate(n)(s, e) /= Reject
    IMPLIES simple_invariant(n)(add(t, e), simple_nextstate(n)(s, e))

  simple_invariant_valid: LEMMA simple_invariant(n)(proj(vt, simple_event?(n)), goto(simple_fsm(n), vt)) 

  data_port_prefix_data_in: LEMMA data_trace(p, vt)`length <= data_in(vt)`length AND
    data_trace(p, vt) = prefix(data_in(vt), data_trace(p, vt)`length)

  data_out_prefix_data_in: LEMMA data_out(vt)`length <= data_in(vt)`length AND
    data_out(vt) = prefix(data_in(vt), data_out(vt)`length)

END simple_fifo


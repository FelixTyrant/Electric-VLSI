<!-- HEADER 8-6: Network Consistency Checking (NCC) -->

<!-- COMMAND Tool/NCC/Schematic and Layout Views of Cell in Current Window -->
<!-- COMMAND Tool/NCC/Cells from Two Windows -->

<h2> NCC Overview </h2>

<h4> Improvements </h4>

Electric can compare two different cells and determine whether their
networks have the same topology.  This operation is sometimes called
Layout vs. Schematic (LVS), but because Electric can compare any two
circuits (including two layouts or two schematics) we use the term Network
Consistency Checking (NCC).
<p>
The Java Electric NCC differs from the C Electric NCC in two
signficant ways.
<OL>
<LI>
  The Java Electric NCC firsts attempts to discover circuit mismatches
  using a new algorithm called "Local Paritioning".  We do this
  because Local Partitioning provides much more precise and
  intelligible mismatch diagnostics.  We fall back upon the <A
  HREF="http://www.cs.washington.edu/research/projects/lis/www/gemini/gemini.html">
  Gemini algorithm</A> (Ebeling, Carl, "GeminiII: A Second Generation
  Layout Validation Program", <I>Proceedings of ICCAD</I> 1988,
  p322-325.) only as a last resort. In practice upwards of 95% of all
  errors are found by Local Partitioning.
</li>
<li>
  The Java Electric NCC has a "hierarchical" mode. When comparing a
  cell hierarchically, NCC first tries to compare the cell's
  descendents.  We <i>strongly</i> recommend this mode to the user
  because it allows the Local Partitioning algorithm to provide even
  more precise and intelligible mismatch diagnostics.
</li>
</ol>
The Java Electric NCC is also significantly faster than the C Electric
NCC.  For example, for one of our chips, C-NCC flat took 48 minutes,
Java-NCC flat took 3.5 minutes, and Java-NCC hierarchical took 15
seconds.
<p>

<h4> Limitations </h4>
NCC has a number of limitations
<ol>
<li>
  NCC does not check the substrate connection of transistors. This is
  because neither C- nor Java- Electric keep track of the connectivity
  of the substrate connection of layout transistors. In fact, layout
  transistors don't have substrate ports. We plan to remedy this.
</li>
<li>
  NCC treats all resistors as short circuits. This is the desired
  behavior for most of the resistors produced by the Asynchronous
  Design Group at Sun. However, it would be nice if certain resistors
  in schematics could be matched up against layout resistors. However,
  neither C- nor Java- Electric support explicit layout resistors. We
  plan to remedy this.
</li>
<li>
  NCC's error messages are completely text based. There is no
  integration into the GUI.  We plan to remedy this.
</li>
</ol>

<h2> NCC menu commands </h2>

<P>
To compare two cells, use these commands (in menu <B>Tool / NCC</B>):
<UL>
<LI>
   <B>Schematic and Layout Views of Cell in Current Window</B>

   Use a heuristic to figure out what to compare against the cell in
   the current window.  If the current cell is a schematic then
   compare it against some layout cell in the same cell group.  If the
   current cell is a layout then compare it against some schematic
   cell in the same cell group.  Since most cell groups have one
   layout cell and one schematic cell, this form of the NCC command is
   usually the most convenient.
</LI>
<LI>
   <B>Cells from two Windows</B>

   Compare the two cells that are displayed in the two opened windows
   (there must be exactly two windows). This is useful when the
   schematic and layout are not in the same cell group. The command
   can also be used to compare schematics with schematics or layout
   with layout. However, the command refuses to compare icon cells
   since icons cells don't have defined connectivity.

</LI>
</UL>

<h2> NCC preferences </h2>

<P>
   NCC options are available in the "NCC" preferences (in menu <B>File
   / Preferences... </B>, "Tools" section, "NCC" tab).
</p>
</p>
<TABLE><TR><TD>
</TD><TD><CENTER><IMG SRC="fig09-22.png" ALT="Figure 9.22"></CENTER></TD></TR></TABLE>
</P>

<h4> Operation panel </h4>

The "Operation" panel allows you to select what kind of NCC operation
to perform.  You can either compare hierarchically, compare flat, or
list all the NCC annotations in the design.  
<p>
We recommend hierarchical over flat comparison because hierarchical
comparisons are faster and the mismatch diagnostics are much more
precise and intelligible. However, transistor size checking of
schematics with automatically sized transistors does not work with
hierarchical comparisons. If you select "Check transistor sizes" and
your schematics include automatically sized transistors you must also
select "Flat Comparison".
</p>
<p>
The best way to use NCC is to initially perform all your comparisons
hierarchically. This will typically require many iterations.  Once you
have gotten your designs to pass hierarchical comparison, turn on size
checking and flat comparison.  This will report transistor size
mismatches.

<h4> Size Checking Panel </h4>

The "Size Checking" panel controls the checking of transistor widths
and lengths. If you enable size checking and your schematics include 
automatically sized transistors then you must also enable flat
comparison.
<p>
NCC does the following when size checking is enabled. After each
topological comparison, NCC checks if it found any topological
mismatches. If NCC found no mismatches then NCC checks for each pair
of matching transistors, the widths and lengths are approximately
equal.
</p>
<p>
The two tolerance boxes allow the user to specify how larger the
larger of the two matched transistors may be than the smaller before
NCC reports a size mismatch. The "Relative size tolerance" box
specifies the difference in percentage. The "Absolute size tolerance"
box specifies the difference in lambda.  NCC reports a size mismatch
when both tolerances are exceeded.

<h4> Checking All Cells Panel </h4>

In hierarchical mode NCC attempts to compare all Cells in the design
starting with those at the leaves and working it's way toward the root.
For that mode it is often best if NCC stops as soon as it finds a
mismatch. To get this behavior the user should check the box: "Halt
after finding the first mismatched Cell".
<p>
However, it is occasionally useful to continue checking even after
mismatches have been detected.  For example, the designer might find
that although cell ABC mismatches, she is unable to fix ABC because
someone else designed it.  When asked to continue, NCC will do the
following when comparing cells that use ABC: 
<ul>
<li>
If NCC found no export mismatches when comparing ABC then NCC will use
the export names to identify corresponding ports in the layout and
schematic. 
</li>
<li> If NCC found export mismatches when comparing ABC then NCC will
flatten the one level of hierarchy: ABC, before performing the
comparison.
</li>
</ul>
<p>
The check box "Don't recheck cells that have passed in this Electric
run" skips the checking of a pair of cells if they have ever passed in
this run of Electric.  Because this command <i>is not</i> smart enough
to recheck the cells after either have changed, this command is of
very limited utility.  At the moment NCC has run sufficiently fast
that it doesn't seem worth the effort to implement anything more
sophisticated.

<h4> Reporting Progress Panel</h4>

This panel controls how verbose NCC is in reporting its progress. Most
users should leave this at 0.

<h4> Error Reporting Panel</h4>

The error reporting panel controls how many error messages are printed
when the Local Partitioning algorithm has failed to find a mismatch
but the Gemini algorithm has.  Most users will want to leave these at
the default setting of 10.

<h2> NCC Annotations </h2>

For certain situations NCC cannot figure out that two cells are
equivalent unless the designer supplies extra information. The
designer supplies this extra information by adding NCC annotations to
layout and/or schematic cells. NCC annotation's are represented by
Java-Electric attributes placed on cells. The attribute's name is
<i>NCC</i>. The attribute's value is one or more lines. Each line
contains a separate NCC annotation. Thus, although a Cell can have at
most one attribute named <i>NCC</i>, that attribute can contain any
number of NCC annotations.

<h4> exportsConnectedByParent <i> < string or regular expression></i> </h4>

Layout cells sometimes contain multiple exports that are supposed to
be connected by the parent cell. For example, a layout cell, A{lay},
might export vdd, vdd_1, vdd_2, and vdd3. The designer expects the
cell that instantiates A{lay} will connect all the vdd exports to a
single net: vdd. However, because the corresponding schematic cell
usually only contains a single export, vdd, the NCC of the schematic
and layout cells fails. This situation is most common for the power
and ground networks, although it occasionally arises for signal
networks such as <i>clock</i> or <i>precharge</i>.
</p>
<p>
Java-Electric's NCC allows the designer to add the annotation:
exportsConnectedByParent to the cell to inform NCC which exports will
be connected by the parent. The keyword is followed by a list of
strings and/or regular expressions. A string matches an export name
exactly, for example: vdd. Thus A{lay} can contain the NCC annotation:
</p>
<p style=padding-left:10px>
exportsConnectedByParent vdd vdd_1 vdd_2
</p>
<p>
Alternatively, the designer can use regular expressions. Regular
expressions begin and end with the character: '/'. Thus A{lay} can
contain the NCC annotation:
</p>
<p style=padding-left:10px>
exportsConnectedByParent vdd /vdd_[0-9]+/
</p>
<p>
When NCC compares a cell with an <i> exportsConnectedByParent </i>
annotation then it performs the comparison as if those exports were
connected. It is safe for NCC to believe this annotation because NCC
also checks the assertion. When NCC encounters an instance of a cell
with an <i> exportsConnectedByParent </i> annotation NCC reports an
error whenever that assertion isn't satisfied.
</p>
<h4> skipNCC <i> < comment> </i> </h4>

The skipNCC annotation should be added to a cell, say B, when:
<ol>
<li>
B{sch} and B{lay} won't pass either flat or hierarchical NCC and
</li>
<li>
you want any hierarchical NCC of the parents of B to flatten the one
level of hierarchy: cell B.
</li>
</ol>
If cell B has a skipNCC annotation, then a hierarchical comparison
won't check B and will simply flatten through the one level of
hierarchy: B.  
<p>
All the characters following the keyword to the end of the
line serve as a comment. This useful for documenting why this
annotation was necessary. When you ask NCC to compare every cell in
the design, NCC will tell you which cells it is skipping and why.  For
example, if cell B includes the NCC annotation: 
</p>
<p style=padding-left:10px>
skipNCC layout is missing ground connection
</p>
<p>
then NCC will print:
<p style=padding-left:10px>
 Skipping NCC of A because layout is missing ground connection. 
</p>
<p>
A common reason for needing this annotation is one that I dislike: the
exports of B{sch} and B{lay} don't match. A skipNCC on B prevents NCC
from reporting export mismatches because 1) cell B is not checked by
itself and 2) when a parent of cell B is checked, B's exports are
discarded when NCC flattens through cell B. Although not always
possible, it's better to fix export mismatches because fixing them
will yield clearer mismatch diagnostics when there is a problem.
</p>

<h4> flattenInstances <i>< string or regular expression></i> ... </h4>
Hierarchical NCCs do not require a perfect match between the schematic
and layout hierarchies. Instead, hierarchical NCC uses heuristics to
determine which cell instances must be flattened and which can be
compared hierarchically. The heuristic sometimes make mistakes. When
that happens the flattenInstances annotation can guide the heuristic.
</p>
<p>
The list of strings and/or regular expressions are used to match
instance names within the cell. Those cell instances that match are
always flattened.  
</p>

<h4> notSubcircuit <i> < comment></i>  </h4>

The designer should add the notSubcircuit annotation to a cell, say B,
if:
<ol>
<li>
B{sch} and B{lay} will pass NCC when compared separately but
</li>
<li>
hierarchical NCC of a parent of B should not treat B as a hierarchical
element but should, instead, flatten through B.
</li>
</ol>
One reason for using this annotation is to correct errors made by the
heuristic that determines which cells to flatten and which to compare
hierarchically.  For example, suppose that the schematics instantiate
cell B{sch} 1000 times and the layout instantiates cell B{lay} 500
times.  In principle one could use the <i>flattenInstances</i>
annotation to inform NCC which instances to keep and which to
flatten. However sometimes that's more work than it's worth and it's
better to add a single <i>notSubcircuit</i> annotation to cell B{sch}
or B{lay} to tell NCC to never treat B as a hierarchical entity.
<p>
When hierarchical NCC encounters a notSubcircuit annotation it prints
a message that includes the comment in a manner similar to skipNCC.
</p>
<p>
The notSubcircuit annotation only affects hierarchical NCCs, it is
ignored by flat NCCs. 
</p>
<h4> joinGroup <i> < cell name></i> </h4> 
<p>
The designer should add a joinGroup annotation to, say, cell B if NCC
should behave as if cell B belonged to a different cell group and that
cell group is in a different library. The cell group to move B to is
that cell group that contains <i> < cell name> </i>. That
specification should be fully qualified: library:cell{view}.
<p>
Memberships in cell groups are important when NCC performs
hierarchical comparisons because NCC assumes that cells in the same
cell group are supposed to be topologically identical. Membership of
two cells in the same Cell group is one criteria NCC uses to decide
that it should treat them as hierarchical entities and it should
compare them separately.
</p>
<p>
Occasionally it is impractical to place the layout and schematic views
of a cell in the same cell group.  For example when layout is
automatically generated from hand drawn schematics it may be better to
place the layout in a different library than the schematics.
</p>

<p>
<h2> Example </h2>

For an example of network consistency checking, open the Samples
library (in menu <B>Help / Load Samples Library</B>) and compare the
cells "tool-NCC{lay}" and "tool-NCC{sch}".  These two cells are
equivalent and the checker will find them to be so.

<!-- TRAILER -->


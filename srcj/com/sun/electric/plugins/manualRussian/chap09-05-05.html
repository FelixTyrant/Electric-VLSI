<!-- NEED 4in -->

<!-- HEADER 9-5-5: ALS Functions -->
Суть функции - альтернативный метод описания состояния.
Связь java методов которые собраны в Electric. Так как количество методов ограничено, а 
правка исходного кода не такое простое заняти, приминение функций актуально.
Возможности очень велики и могут применятся для эффективного моделирования комплекса схем.
Это позволяет проектировщику работать на высоком уровне абстракции т.к. глобальная система
может разробатыватся до появления элементной базы. примеры содержатся в арифметическо-логических
устойствах в RAM и ROM, и других устройствах которые легче описать програмными алгоритмами, чем 
описанием компанентов.
 Для добавления функции к симуляции, редактируйте модуль "com.sun.electric.tool.simulation.als.UserCom.java".
<P>
Функция объявляется как <B>function</B> ниже приводится список и имена экспортов.
Формат представлен ниже:
<P>
<CENTER><TABLE>
<TR><TD><B>Format:</B></TD><TD>function <I>name</I>(<I>signal1</I>, <I>signal2</I>,
<I>signal3</I>, ... <I>signalN</I>)</TD></TR>
<TR><TD><B>Example:</B></TD><TD>function JK_FF(ck, j, k, out)</TD></TR>
<TR><TD></TD><TD>function DFFLOP(data_in, clk, data_out)</TD></TR>
<TR><TD></TD><TD>function BUS_TO_STATE(b7,b6,b5,b4,b3,b2,b1,b0, output)</TD></TR>
<TR><TD></TD><TD>function STATE_TO_BUS(input, b7,b6,b5,b4,b3,b2,b1,b0)</TD></TR>
</TABLE></CENTER>
<P>
Имена согласованы с Java методом, который будет обрабатывать параметры функции в порядке приведения их  в списке.
В настоящее врея доступно четыре функции, которые приведины в списке.
Это два тригера (JK и D) и два числовах преобразователя, которые приобразуют сигнал восми разрядной шины в шеснацетеричное число.
<P>

<H3>Объявление входных и выходных портов</H3>
<P>
Аргументы <B>i:</B> и <B>o:</B> которые следуют после объявления функции, нужны для того чтобы сообщить симулятору
какие сигналя ответственны за управление функцией, а какие управляют другими событиями.
Формат объявления входной функции приведен ниже:
<P>
<CENTER><TABLE>
<TR><TD><B>Format:</B></TD><TD>i: <I>signal1</I> <I>signal2</I> <I>signal3</I> ... <I>signalN</I></TD></TR>
<TR><TD><B>Example:</B></TD><TD>i: b7 b6 b5 b4 b3 b2 b1 b0</TD></TR> 
<TR><TD></TD><TD>i: input phi phi_bar set reset</TD></TR>
</TABLE></CENTER>
<P>
Формат объявления выходной функции:
<P>
<CENTER><TABLE>
<TR><TD><B>Format:</B></TD><TD>o: <I>signal1</I> <I>signal2</I> <I>signal3</I> ... <I>signalN</I></TD></TR>
<TR><TD><B>Example:</B></TD><TD>o: out1 out2 out3</TD></TR>
<TR><TD></TD><TD>o: q q_bar</TD></TR>
</TABLE></CENTER>
<P>

<H3>Остальная спецификация</H3>
<P>
Существует набор команд способных влият на описываемые функции.
Аргумент <B>t:</B> используется для определения задержки между входом и выходом.
Аргумент <B>load</B> используется для указания емкосного сопротивления входа и выхода.
Аргумент <B>priority</B> нужен для определения списков приоритетов.
Аргумент <B>set</B> требуется для установления какого-ибо логического состояния до начала симуляции.
<P>

<H3>Пример использования функции</H3>
<P>
Описание 3 битного регистра на базе D тригера:
<PRE>
   model main(input, ck, q2, q1, q0)  
   stage0: DFFLOP(input, ck, q0)  
   stage1: DFFLOP(q0, ck, q1)  
   stage2: DFFLOP(q1, ck, q2)

   function DFFLOP(data_in, clock, output)  
   i: clock  
   o: output  
   t: delta=10e-9  
   load clock=2.0
</PRE>
Обратите внимание, что единственный управляющий сигнал для тригера это clock.
Если сигнал "data_in" будет сробатывать при изменени состояния управляющего сигнала clock, то нет необходимости
обращятся к функции. Таким образом проектировщик может писать функцию так, что данные обрабатываются только когда
идет обращение к функции и сигнал clock утвержден в высоком уросне(нарастающий фронт сигнала).
Если при обращении к функции, сигнал clock низкого уровня(падающий фронт), то процедура проигнорирует информацию
и вернет управление обратно програме симуляции. 
<P>
Вызаваемвй аргумент к java устанавливается связанным списком сигнальных точек.
Симулятор помещяет в этот список аргументы в порядке их появления при обявлении функции.
Для корректной выборки информации из этого списка и составления нового, программисту потребуется знания о "внутренностях"
симулятора. Обсуждение програмной сущьности написания функций выходят за рамки этой документации.\

<!-- TRAILER -->

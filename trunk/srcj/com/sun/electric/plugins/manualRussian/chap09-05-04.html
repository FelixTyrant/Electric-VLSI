<!-- NEED 4in -->

<!-- HEADER 9-5-4: ALS Gates -->

Входное значения является первичным фактором для определения состояния.
Для определения входного значения используется таблица истенности.
Входных значений достаточно для сосовления описания множества состояний.
<P>
Входные состояния обявляются как <B>gate</B> и записыватся в теле описания.
В обявление входа включается имя и список непосредственно входных сигналов.
Пример обявления смотри ниже. 
<P>
<CENTER><TABLE>
<TR><TD><B>Format:</B></TD><TD>gate <I>name</I>(<I>signal1</I>, <I>signal2</I>,
<I>signal3</I>, ... <I>signalN</I>)</TD></TR>
<TR><TD><B>Example:</B></TD><TD>gate nor2(in1, in2, out) </TD></TR>
<TR><TD></TD><TD>gate and3(a, b, c, output) </TD></TR>
</TABLE></CENTER>
<P>
Количество входных сигналов не ограничено. Если при обявлении входных сигналов не хвотаетстроки,
то просто продолжети список на другой строке.  
<P>

<H3> i: и o: формулировки (Вход\Выход)</H3>
<P>
Объекты <B>i:</B> и <B>o:</B> используются при создании таблицы истонности для приметивов.
Имя сигнала и логическое утверждение следующие за символом <B>i:</B>
представляют собой одно из возможных состояний входа. Если входные состояния узла
определяются условиями(прим. на вход пришел сигнал и ничего тут не попишешь), то список выходных состояний, обявленных 
как <B>o:</B>, составляется симулятором. Ниже приведена таблица истенности для элемента AND с двумя входами. 
<PRE>	
   gate and2(in1, in2, output)  
   i: in1=H in2=H  o: output=H 
   i: in1=L        o: output=L 
   i: in2=L        o: output=L 
   i:              o: output=X
</PRE>
Последняя строчка таблицы отображает дефолтовое состояние, в случае если никокое из описанных
выше состояний не выполняется.
Важно отметить, что симулятор обрабатывает состояния в той последовательности в которой они были описаны в 
таблице истенности. В процессе симуляции, если на вход приходит верное значение(прим. верным считается значение
определенное в таблице истенности), симулятор сразуже выстовляет на выходе соответствующие значение. 
<P>

<H3>Добавочная информация о входном сигнале</H3>
<P>
Помимо непосредственного определения величины сигнала, мы при аргументе <i>I:</i> можем задавать определенное 
условие, при выполнении кторого дальнейшая обработка актуальна. (см. пример ниже)
<P>
<CENTER><TABLE>
<TR><TD><B>Format:</B></TD><TD><I>signal</I> &lt;operator&gt; <I>state_value</I></TD></TR>
<TR><TD><B>or:</B></TD><TD><I>signal</I> &lt;operator&gt; <I>other_signal</I></TD></TR>
<TR><TD><B>Operators:</B></TD><TD>=  Test if equal</TD></TR>
<TR><TD></TD><TD>!  Test if not equal</TD></TR>
<TR><TD></TD><TD>&lt;  Test if less than</TD></TR>
<TR><TD></TD><TD>&gt;  Test if greater than</TD></TR>
<TR><TD><B>Example:</B></TD><TD>node1 = H</TD></TR>
<TR><TD></TD><TD>input1 ! input2</TD></TR>
<TR><TD></TD><TD>node3 &lt; 16</TD></TR>
</TABLE></CENTER>
<P>
<H3>Добавочная информация о выходном сигнале</H3>
<P>
При аргументе <B>o:</B> можно задавать некотоые математические операции.
Если можно установить сигнал в определенное логическое состояние, то возможно и дальнейщее преобразование.
(см. пример)
<P>
<CENTER><TABLE>
<TR><TD><B>Format:</B></TD><TD><I>signal</I> [ &lt;operator&gt; <I>operand</I> [ @ &lt;strength&gt; ] ]</TD></TR>
<TR><TD><B>Operators:</B></TD><TD>=  equate signal to value of operand</TD></TR>
<TR><TD></TD><TD>+  increment signal by value of operand</TD></TR>
<TR><TD></TD><TD>-  decrement signal by value of operand</TD></TR>
<TR><TD></TD><TD>*  multiply signal by value of operand</TD></TR>
<TR><TD></TD><TD>/  divide signal by value of operand</TD></TR>
<TR><TD></TD><TD>%  modulo signal by value of operand</TD></TR>
<TR><TD><B>Strengths:</B></TD><TD>0  off</TD></TR>
<TR><TD></TD><TD>1  node</TD></TR>
<TR><TD></TD><TD>2  gate</TD></TR>
<TR><TD></TD><TD>3  VDD</TD></TR>
<TR><TD><B>Example:</B></TD><TD>qbar = H@3</TD></TR>
<TR><TD></TD><TD>out1 + 3</TD></TR>
<TR><TD></TD><TD>out + out1@4</TD></TR>
<TR><TD></TD><TD>node1 % modulus_node</TD></TR>
</TABLE></CENTER>
<P>
Важно отметить, что логическое состояние операнда может быть определенно как явно (H, 3), так и не явно,
через имя сигнала (out1, modulus_node). В неявном способе адресации, величена сигнала, определяется как операнд с использованием
матиматических вычислений. Указание мощьности является дополнение, если не указать вообще ничего, то по дефолту мощьность затвора
2 и она будет соотносится с выходным сигналом.
<P>
<H3>Аргумент t (Time Delay(время задержки))</H3>
<P>
Время распространения задержки затвора можно указать при аргументи t:.
Формат записи приведен ниже: 
<P>
<CENTER><TABLE>
<TR><TD><B>Format:</B></TD><TD>t: &lt;mode&gt; = <I>value</I> { + &lt;mode&gt; = <I>value</I> ... }</TD></TR>
<TR><TD><B>Mode:</B></TD><TD>delta: fixed time delay in seconds</TD></TR>
<TR><TD></TD><TD>linear: random time delay with uniform distribution</TD></TR>
<TR><TD></TD><TD>random: probability function with values between 0 and 1.0</TD></TR>
<TR><TD><B>Example:</B></TD><TD>t: delta=5.0e-9</TD></TR>
<TR><TD></TD><TD>t: delta=1.0e-9 + random=0.2</TD></TR>
</TABLE></CENTER>
<P>
Можно объдинить многократное распределении выбора времени, использавав операнд +.
Такое может произойти, если затвор управляется сигналом единичного заряда(например входом минемальных размеров инвертора).
<P>
При аргументе t устанавливается параметр выбора времени для каждого столбца табдицы истенности
(аргументя i: и o: , соответственно формируют эту таблицу), который укажыватся в описании gate.
При использованни нескольких аргументов t, можно задать повышенное и пониженное время распростронения.
Предположим, что у элемента NAND выход имеет аргумент при <I>t(lh)</I> = 1.0 наносекунд, тогда
описание выхода в этом случае будет выглядет:
<PRE>
   gate nand2(in1, in2, output)  
   t: delta=3.0e-9  
   i: in1=H in2=H   o: output=L  
   t: delta=1.0e-9  
   i: in1=L         o: output=H  
   i: in2=L         o: output=H
</PRE>
Пример показывает, что когда на двух входах 1, выход упадет до 0 после жадержки в 3.0 наносекунды, и что если 
на входе был 0, то он поднимется до 1, после задержки в 1.0 наносекунду. 
<P>
<H3>определение Дельта времени задержки при аргументе t:</H3>
<P>
Дельта используется для указания фиксированного времени.
Формат Дельта времент приведен ниже: 
<P>
<CENTER><TABLE>
<TR><TD><B>Format:</B></TD><TD>delta = <I>value</I></TD></TR>
<TR><TD><B>Example:</B></TD><TD>delta = 1.0</TD></TR>
<TR><TD></TD><TD>delta = 2.5e-9</TD></TR>
</TABLE></CENTER>
<P>
Значение приведенное с Дельта, является неподвижной задержкой времени в секундах.
<P>
<H3>Линейное распределение задержки при аргументе t: Statement</H3>
<P>
под линейным распространением понемается случайный период времени который имеет однородное распределение 
вероятности. Формат такой записи приведен ниже:
<P>
<CENTER><TABLE>
<TR><TD><B>Format:</B></TD><TD>linear = <I>value</I></TD></TR>
<TR><TD><B>Example:</B></TD><TD>linear = 1.0</TD></TR>
<TR><TD></TD><TD>linear = 2.0e-9</TD></TR>
</TABLE></CENTER>
<P>
Значение приведенное с линейным представлением являеся средним значением времени задержки
в секундах для однородного распределения.
Из примера, очевидно,что есть одинаковая вероятность того, что время задержки будет где-нибудь 
между 0 и 2 наносекунд.
<P>

<H3>The Random Probability Function of the t: Statement</H3>
<P>
The random probability function enables the user to model things which occur on a percentage basis
(e.g. bit error rate, packet routing).
The format for random probability declaration is shown below:
<P>
<CENTER><TABLE>
<TR><TD><B>Format:</B></TD><TD>random = <I>value</I></TD></TR>
<TR><TD><B>Example:</B></TD><TD>random = 0.75</TD></TR>
<TR><TD></TD><TD>random = 0.25</TD></TR>
</TABLE></CENTER>
<P>
The value associated with random declaration must be in the range 0.0 &lt;= <I>value</I> &lt;= 1.0.
This value represents the percentage of the time that the event is intended to occur.
<P>
A gate which uses the random probability feature must be operated in parallel with
another gate which has a common event driving input.
Both these gates should have the same timing distributions associated with them.
When the common input changes state, a probability trial is performed.
If the probability value is less than or equal to the value specified in the random declaration,
the gate containing the random declaration will have its priority temporarily
upgraded and its outputs will change state before the outputs of the other gate.
This feature gives the user some level of control (on a percentage basis)
over which gate will process the input data first.
<P>
As an example, a system which models a communication channel that corrupts 1%
of the data bytes that pass through it is shown below:
<P>
<CENTER><TABLE><TR><TD><CENTER><IMG SRC="fig09-35.png" ALT="Figure 9.35"></CENTER></TD><TD>
<PRE>
   model main(in, out)
   trans1: good(in, out)
   trans2: bad(in, out)

   gate good(in, out)
   t: delta=1.0e-6
   i: in>0x00    o: out=in  in=0x00

   gate bad(in, out)
   t: delta=1.0e-6 + random=0.01
   i: in>0x00    o: out=0xFF in=0x00
</PRE>
</TD></TR></TABLE></CENTER>
<P>
The netlist describes a system where ASCII characters are represented by 0x01-0x7F.
The value 0x00 indicates there is no data in the channel and the value 0xFF indicates a corrupted character.
It is assumed that there is an external data source which supplies characters to the channel input.
It should be noted that the random declaration is placed on only one of the two gate
descriptions rather than both of them.
Unpredictable events occur if the random declaration is placed on both gate descriptions.
<P>

<H3>The Fanout Statement</H3>
<P>
The <B>fanout</B> statement is used to selectively enable/disable fanout calculations
for a gate when the database is being compiled.
The format for a <B>fanout</B> statement is shown below:
<P>
<CENTER><TABLE>
<TR><TD><B>Format:</B></TD><TD>fanout = on</TD></TR>
<TR><TD><B>or:</B></TD><TD>fanout = off</TD></TR>
</TABLE></CENTER>
<P>
When fanout calculation is enabled (the default setting for all gates),
the simulator scans the database and determines the total load that the gate is driving.
It then multiplies the gate timing parameters by an amount proportional to the load.
If an inverter gate was found to have a propagation delay time of 1 nanosecond when driving a single inverter input,
an instance of that gate would have a propagation delay time of 3 nanoseconds
if it was driving a load equivalent to 3 inverter inputs.
<P>
If fanout calculation is turned off for a gate primitive,
fanout calculations for all instances of that gate will be ignored.
This feature allows the user to force switching times to a particular value
and not have them modified by the simulator at run time.
<P>

<H3>The Load Statement</H3>
<P>
The <B>load</B> statement is used to set the relative loading (capacitance) for an input or output signal.
The format of a <B>load</B> statement is shown below:
<P>
<CENTER><TABLE>
<TR><TD><B>Format:</B></TD><TD>load <I>signal1</I> = <I>value</I> { <I>signal2</I> = <I>value</I> ... }</TD></TR>
<TR><TD><B>Example:</B></TD><TD>load in1=2.0  in2=1.5  in3=1.95</TD></TR>
<TR><TD></TD><TD>load sa=2.5</TD></TR>
</TABLE></CENTER>
<P>
The value associated with the signal represents the relative capacitance of the simulation node.
When the timing parameters are specified for a gate description,
it is assumed that they are chosen for the situation where the gate is driving a single (1.0)
unit load such as a minimum size inverter input.
The load command tells the simulator that some input structures are smaller or larger
(more capacitive) than the reference standard.
The simulator, by default, assumes that all signals associated with gate primitives have a load rating of 1.0
(unit load) unless they are overridden by a <B>load</B> statement.
<P>

<H3>The Priority Statement</H3>
<P>
The <B>priority</B> statement is used to establish the scheduling priority for a gate primitive.
The format for a <B>priority</B> statement is shown below:
<P>
<CENTER><TABLE>
<TR><TD><B>Format:</B></TD><TD>priority = <I>level</I></TD></TR>
<TR><TD><B>Example:</B></TD><TD>priority = 1</TD></TR>
<TR><TD></TD><TD>priority = 7</TD></TR>
</TABLE></CENTER>
<P>
In the event that two gates are scheduled to update their outputs at exactly the same time,
the gate with lowest priority level will be processed first.
All gate primitives are assigned a default priority of 1 unless they contain random timing
declarations in the gate description.
In this case the primitive is assigned a default priority of 2.
This base priority can be temporarily upgraded to a value of -1 if a random trial is successful
during the course of a simulation run.
The user is advised to leave the priority settings at their default values unless there is a
specific requirement which demands priority readjustment.
<P>

<H3>The Set Statement</H3>
<P>
The <B>set</B> statement is used to initialize signals to specific logic states before the simulation run takes place.
The format for the <B>set</B> statement is shown below: 
<P>
<CENTER><TABLE>
<TR><TD><B>Format:</B></TD><TD>set <I>signal1</I> = &lt;state&gt; @ { &lt;strength&gt; }</TD></TR>
<TR><TD></TD><TD><I>signal2</I> = &lt;state&gt; @ { &lt;strength&gt; }</TD></TR>
<TR><TD><B>Example:</B></TD><TD>set input1=H@2 input2=L input3=X@0</TD></TR>
<TR><TD></TD><TD>set count=4 multiplier=5 divisor=7@2</TD></TR>
</TABLE></CENTER>
<P>
If the user does not specify a strength value,
the signal will be assigned a default logic strength of 3 (VDD).
This default setting will override any gate output
(because the default strength of 2 is used for gate outputs).
<P>
The user will find this feature useful in situations where some of the inputs to a logic gate
need to be set to a fixed state for the entire duration of the simulation run.
For example, the set and reset inputs of a flip flop should be tied low if these inputs are
not being driven by any logic circuitry.
All instances of a gate entity which contains a <B>set</B>
statement will have their corresponding simulation nodes set to the desired state.

<!-- TRAILER -->

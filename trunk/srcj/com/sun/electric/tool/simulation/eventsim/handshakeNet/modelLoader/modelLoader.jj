/**
 * JavaCC file
 */
 
options {
  JDK_VERSION = "1.5";
  STATIC = false;
}
PARSER_BEGIN(HandshakeNetParser)
package com.sun.electric.tool.simulation.eventsim.handshakeNet.modelLoader;

import java.lang.reflect.Constructor;
import java.util.Set;

// import com.sunlabs.handshakeNet.modelBuilder.ModelDescription;
import com.sun.electric.tool.simulation.eventsim.core.common.Parameters;
import com.sun.electric.tool.simulation.eventsim.core.engine.Director;
import com.sun.electric.tool.simulation.eventsim.core.globals.Globals;
import com.sun.electric.tool.simulation.eventsim.core.hierarchy.CompositeEntity;
import com.sun.electric.tool.simulation.eventsim.handshakeNet.channel.Channel;
import com.sun.electric.tool.simulation.eventsim.handshakeNet.channel.RendezvousChannel;
import com.sun.electric.tool.simulation.eventsim.core.classRegistry.ClassRegistry;
import com.sun.electric.tool.simulation.eventsim.handshakeNet.component.Component;
import com.sun.electric.tool.simulation.eventsim.handshakeNet.terminal.InputTerminal;
import com.sun.electric.tool.simulation.eventsim.handshakeNet.terminal.OutputTerminal;
import com.sun.electric.tool.simulation.eventsim.handshakeNet.modelBuilder.ComponentRecord;
import com.sun.electric.tool.simulation.eventsim.handshakeNet.modelBuilder.ChannelRecord;
import com.sun.electric.tool.simulation.eventsim.handshakeNet.modelBuilder.ConnectionPoint;

public class HandshakeNetParser {

	private ClassRegistry classRegistry= ClassRegistry.getInstance();
	private ModelDescription modDes= ModelDescription.getInstance();

	public static void main(String args[]) 
	throws ParseException, TokenMgrError {
 		HandshakeNetParser parser= new HandshakeNetParser(System.in);
 		parser.start();
	}
}

PARSER_END(HandshakeNetParser)

SKIP :
{
 	" "
|	"\r"
|	"\t"
|	"\n"
}

TOKEN : /* keywords */
{
	<MODEL: "model" >
|	<COMPONENT: "component" >
|	<CONNECTION: "connection" >
|	<CHANNEL: "channel" >
|	<TYPE: "type" >
|	<PARAMETER: "parameter" >
|	<FROM: "from" >
|	<TO: "to" >
|	<INSTANCEOF: "instanceof" >
}

SPECIAL_TOKEN :
{
  <SINGLE_LINE_COMMENT: "//" (~["\n", "\r"])* ("\n" | "\r" | "\r\n")?>
}

MORE: { "/*" : IN_COMMENT }
<IN_COMMENT>MORE: { < ~[] > }
<IN_COMMENT>SKIP: { "*/": DEFAULT }

TOKEN :

{
	< #SYMBOL : ["a"-"z"] | ["A"-"Z"] | "-" | "_" >
|   < #DIGIT: ["0" - "9"] >
}

TOKEN : 
{	
	< NUMBER: ("-")?(<DIGIT>)+ >
|	< NAME: (<SYMBOL> | <DIGIT>)* (<SYMBOL>)+ (<SYMBOL> | <DIGIT>)* >
|	< LEFT_BRACE: "{" >
|	< RIGHT_BRACE: "}" >
|   < ARROW: ("->" | "=>") >
|  	< STRING_LITERAL:       
	  "\""
      (   (~["\"","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            )
          )
      )*
      "\"" >
}

void start() :
{ 
	Token t;
}
{
	[
		<MODEL>
		t= <NAME>
		{
			// model name. Do we reall need that?
			modDes.name= t.image;
		}
	]

	[ ";" ]
	
	( component() )+
	
	( channel() )*
	
}

void component() :
{
	Token t;
	ComponentRecord cmpRecord;
	Parameters parameters= new Parameters();
}
{
	<COMPONENT>
	t= <NAME>
	{
		// start a new component record
		cmpRecord= new ComponentRecord();
		// remember the line where the record was defined
		cmpRecord.line= jj_input_stream.getBeginLine();
		// store component name
		cmpRecord.name= t.image;
	}
	<INSTANCEOF>
	t= <NAME>
	{
 		// does this class exist in the registry?
 		String className= t.image;
 		Class c= classRegistry.getComponentType(className);
 		if (c != null) {
 			// class found, record it
 			cmpRecord.type= c;
 			cmpRecord.typeName= className;
 		}
 		else {
 			// class not found, error
 			throw new ParseException("Error in line " 
 					+ jj_input_stream.getBeginLine()
 					+ ": Class tag \"" + className 
 					+ "\" not recognized");
 		}
	}
	[
		<LEFT_BRACE>
		( componentParameter(cmpRecord, parameters) )*
		<RIGHT_BRACE>
	]
	[ ";" ]
	{
		// record the parameters
		cmpRecord.attributes= parameters;
		// add component to the model
		modDes.componentNameMap.put(cmpRecord.name, cmpRecord);
	}
}

void componentParameter(ComponentRecord cmpRecord, Parameters parameters) :
{
	Token t;
	String parameterName=null;
	String parameterValue=null;
}
{
	<PARAMETER> 
	t= <NAME>
	{
		parameterName= t.image;
	}
	"="
	(
		t= <NAME> 
		{
			parameterValue= t.image;
		}
		| t= <STRING_LITERAL>
		{
			parameterValue= t.image.substring(1, t.image.length()-1);
		}
		| t= <NUMBER>
		{
			parameterValue= t.image;
		}	
		
		{
			parameters.add(parameterName, parameterValue);
		}
	)
	[ ";" ]
	
}

void channel() :
{ 
	Token t;
	ChannelRecord channelRecord;
	Parameters channelParameters;
}
{
	( <CONNECTION> | <CHANNEL> )
	t= <NAME>
	{
		// start a new channel record
		channelRecord= new ChannelRecord();
		channelParameters= new Parameters();
		// record the name
		channelRecord.name= t.image;
		// record the line where the channel is defined
		channelRecord.line= jj_input_stream.getBeginLine();
	}
	<LEFT_BRACE>
	( from(channelRecord) )+
	( to(channelRecord) )+
	( channelParameter(channelRecord, channelParameters) )*
	<RIGHT_BRACE>
	{
		// record the parameters
		channelRecord.attributes= channelParameters;
		// add the connection to the model
		modDes.connectionRecordList.add(channelRecord);
	}
}


void from(ChannelRecord channelRecord) :
{
	Token t;
	ConnectionPoint connectionPoint;
}
{
	<FROM>
	t= <NAME>
	{
		// start a new connection point
		connectionPoint= new ConnectionPoint();
		// record the line
		connectionPoint.line= jj_input_stream.getBeginLine();
		// record the component name
		connectionPoint.componentName= t.image;
		if (!modDes.componentNameMap.containsKey(connectionPoint.componentName)) {
			throw new ParseException("Error in line "
				+ connectionPoint.line
			+ ": component "
			+ connectionPoint.componentName
			+ " was not defined, therefore"
			+ " the connection has an unkown end.");
		}
	}
	"."
	t= <NAME>
	{
		// record terminal name
		connectionPoint.terminalName= t.image;
		
		// want to check whether this terminal exists?????
		
		// add connection point to the set of connection point
		boolean check= channelRecord.sources.add(connectionPoint);
		if (!check) {
			// connection specified twice    				
			throw new ParseException("Error in line " 
					+ connectionPoint.line
					+ ": The end point of the connection"
				+ " was specified twice.");			
		}
	}
	[ ";" ]
}

void to(ChannelRecord channelRecord) :
{ 
	Token t;
	ConnectionPoint connectionPoint;
}
{
	<TO>
	t= <NAME>
	{
		// start a new connection point
		connectionPoint= new ConnectionPoint();
		// record the line
		connectionPoint.line= jj_input_stream.getBeginLine();
		// record the component name
		connectionPoint.componentName= t.image;
		if (!modDes.componentNameMap.containsKey(connectionPoint.componentName)) {
			throw new ParseException("Error in line "
				+ connectionPoint.line
			+ ": component "
			+ connectionPoint.componentName
			+ " was not defined, therefore"
			+ " the connection has an unkown end.");
		}
	}
	"."
	t= <NAME>
	{
		// record terminal name
		connectionPoint.terminalName= t.image;
		// add connection point to the set of connection point
		boolean check= channelRecord.destinations.add(connectionPoint);
		if (!check) {
			// connection specified twice    				
			throw new ParseException("Error in line " 
					+ connectionPoint.line
					+ ": The end point of the connection"
				+ " was specified twice.");			
		}
	}
	[ ";" ]	
}

void channelParameter(ChannelRecord channelRecord, Parameters channelParameters) :
{
	Token t;
	String parameterName;
	String parameterValue;
}
{
	<PARAMETER>
		t= <NAME>
	{
		parameterName= t.image;
	}
	"="
	(
		t= <NAME> 
		{
			parameterValue= t.image;
		}
		| t= <STRING_LITERAL>
		{
			parameterValue= t.image.substring(1, t.image.length()-1);
		}
		| t= <NUMBER>
		{
			parameterValue= t.image;
		}
	)	
	{
		channelParameters.add(parameterName, t.image);
	}
	[ ";" ]
}
package com.sun.electric.tool.simulation.eventsim.handshakeNet.terminal;

import com.sun.electric.tool.simulation.eventsim.core.engine.Command;
import com.sun.electric.tool.simulation.eventsim.core.engine.EventSimErrorException;
import com.sun.electric.tool.simulation.eventsim.core.hierarchy.CompositeEntity;
import com.sun.electric.tool.simulation.eventsim.core.simulation.Delay;
import com.sun.electric.tool.simulation.eventsim.handshakeNet.terminal.TerminalDefaults;


abstract public class OutputTerminal extends Terminal {

	protected Delay outputAvailableDelay= TerminalDefaults.OUTPUT_AVAILABLE_DELAY_DEF;
	protected int outputAvailableDelayVariation= TerminalDefaults.OUTPUT_AVAILABLE_DELAY_VARIATION_DEF;
	protected Delay outputUnavailableDelay= TerminalDefaults.OUTPUT_UNAVAILABLE_DELAY_DEF;
	protected int outputUnavailableDelayVariation= TerminalDefaults.OUTPUT_UNAVAILABLE_DELAY_VARIATION_DEF;
	protected Delay outputAckDelay= TerminalDefaults.OUTPUT_ACK_DELAY_DEF;
	protected int outputAckDelayVariation= TerminalDefaults.OUTPUT_ACK_DELAY_VARIATION_DEF;

	
	/** To be engaged when an output is acknowledged. Provided by attached component worker */
	protected Command outputAckCmd= null;
	// the data that is passed on
	protected Object myData=null;
	// has the last outbut been acked?
	protected boolean ackHere= true;
	
	public OutputTerminal(String n) {
		super(n);
		setDelays();
	} // constructor

	public OutputTerminal(String name, CompositeEntity g) {
		super(name, g);
		setDelays();
	} // constructor
	
	/**
	 * Set delays with "global values", otherwise let them remain at their
	 * default values.
	 */
	protected void setDelays() {
		Integer ad= globals.intValue(TerminalDefaults.OUTPUT_AVAILABLE_DELAY);
		if (ad != null) outputAvailableDelay= new Delay(ad);
		Integer adv= globals.intValue(TerminalDefaults.OUTPUT_AVAILABLE_DELAY_VARIATION);
		if (adv != null) outputAvailableDelayVariation= adv;

		Integer uad= globals.intValue(TerminalDefaults.OUTPUT_UNAVAILABLE_DELAY);
		if (uad != null) outputUnavailableDelay= new Delay(uad);
		Integer uadv= globals.intValue(TerminalDefaults.OUTPUT_UNAVAILABLE_DELAY_VARIATION);
		if (uadv != null) outputUnavailableDelayVariation= uadv;
		
		Integer ackd= globals.intValue(TerminalDefaults.OUTPUT_ACK_DELAY);
		if (ackd != null) outputAckDelay= new Delay(ackd);
		Integer ackdv= globals.intValue(TerminalDefaults.OUTPUT_ACK_DELAY_VARIATION);
		if (ackdv != null) outputAckDelayVariation= ackdv;
	} // setDelays	

	/** 
	 * Set the command that the terminal invokes when an output is acknowledged.
	 * It is the responsibility of the component worker to provide this command. 
	 */	
	public void setOutputAckCommand(Command c) {
		outputAckCmd= c;
	} // setOutputAckCommand
	
	// the data that is being passed on
	public Object getData() {
		return myData;
	} // getData
	
	
	/**
	 * Declare that the output is available.
	 * Informs the channel that the data is available,
	 * possibly with a specified delay
	 * @param data data that is available
	 * @throws EventSimErrorException 
	 */
	abstract public void outputAvailable(Object data) throws EventSimErrorException;
	
	/**
	 * Declare that the output is available, with additional delay
	 * The additional delay is cummulative with the terminal delay 
	 * @param data data that is available to output
	 * @param d delay before the data can be produced
	 * @throws EventSimErrorException 
	 */
	abstract public void outputAvailable(Object data, Delay d) throws EventSimErrorException;

	/** retract the output 
	 * @throws EventSimErrorException */
	abstract public void outputUnavailable() throws EventSimErrorException;
	
	/** called by the channel when an output has been acknowledged */
	abstract public void outputAck();
	

	// delay setters and accessors
	
	public void setOutputAvailableDelay(Delay d) {
		outputAvailableDelay= d;
	} // setOutputAvailableDelay
	
	public Delay getOutputAvailableDelay() {
		return outputAvailableDelay;
	} // getOutputAvailableDelay
	
	public void setOutputUnavailableDelay(Delay d) {
		outputUnavailableDelay= d;
	} // setOutputUnavailableDelay
	
	public Delay geOutputUnavailableDelay() {
		return outputUnavailableDelay;
	} // getOutputUnavailableDelay
	
	public void setOutputAckDelay(Delay d) {
		outputAckDelay= d;
	} // setOutputAckDelay
	
	public Delay getOutputAckDelay() {
		return outputAckDelay;
	} // getOutputAckDelay
	
	// has the ack for the last output been received?
	public boolean hasAck() {
		return ackHere;
	}
	
	@Override
	public boolean selfCheck() {
		boolean check= super.selfCheck();
		if (outputAckCmd == null) {
			logError("Self check failed: outputAckCmd == null");
			check= false;
		}
		return check;
	}
	
	public final void logOutputAvailable(Object data) {
		if (journalActivity) {
			logEvent("Output generated by ComponentWorker "
					+ myWorker.getAlias() + ", id= " + myWorker.getID() 
					+ ": " + data);
		}
	} // logOutputAvailable
	
	public final void logOutputUnavailable() {
		if (journalActivity) {
			logEvent("Component worker retracted data" 
					+ myWorker.getAlias() + ", id= " + myWorker.getID());
		}
	} // logOutputUnavailable
	
	public final void logAckOutput() {
		if (journalActivity) {
			logEvent("Output acknowledged by channel "
					+ myChannel.getAlias() + ", " + myChannel.getID());
		}
	} // logAckInput
		

} // class OutputTerminal
